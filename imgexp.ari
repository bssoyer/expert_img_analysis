	

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                   %
%                             - IMGEXP -                            %
%                                                                   %
%          A simple rule-based Expert System for advising           %
%                                                                   %
%            Edge Detection algorithms in Image Analysis            %
%                                                                   %
%                  Copyright (C) by Burak S. Soyer                  %
%                                                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


/*    			Type in begin/0 to start     		    

?- begin.

*/


%                                                                   %
%--------------------        KNOWLEDGE BASE     --------------------%
%                                                                   %
op_name(operator,edge_det).
main_goal(edge_det,edge_detection).
input(edge_det,image).
output(edge_det,image).
main_decomp(edge_det,[spatial_op,point_op,thresholding]).

op_name(spatial,differential).
tool(sobel,spatial_op).
input(sobel,image).
output(sobel,edge_map).
nondecomp(sobel,[]).

op_name(spatial,differential).
tool(roberts,spatial_op).
input(roberts,image).
output(roberts,edge_map).
nondecomp(roberts,[]).

op_name(spatial,differential).
tool(prewitt,spatial_op).
input(prewitt,image).
output(prewitt,edge_map).
nondecomp(prewitt,[]).

op_name(spatial,template).
tool(compass_gradient,spatial_op).
input(compass_gradient,image).
output(compass_gradient,edge_map).
nondecomp(compass_gradient,[]).

op_name(spatial,template).
tool(kirsch,spatial_op).
input(kirsch,image).
output(kirsch,edge_map).
nondecomp(kirsch,[]).

op_name(spatial,template).
tool(three_level_template,spatial_op).
input(three_level_template,image).
output(three_level_template,edge_map).
nondecomp(three_level_template,[]).

op_name(operator,rms).
tool(rms,point_op).
input(rms,edge_map).
output(rms,vector).
nondecomp(rms,[]).

op_name(operator,mag).
tool(mag,point_op).
input(mag,edge_map).
output(mag,vector).
nondecomp(mag,[]).

op_name(operator,max).
tool(max,point_op).
input(max,edge_map).
output(max,vector).
nondecomp(max,[]).

op_name(operator,threshl).
tool(threshl,thresholding).
input(threshl,vector).
output(threshl,edge_points).
nondecomp(threshl,[]).

bad_sequence([roberts,max,threshl]).
bad_sequence([roberts,mag,threshl]).
bad_sequence([kirsch,rms,threshl]).


/*
   These rules are used by the Expert System (ES) to advise
   after the user has entered her options.
*/
rule(roberts:rms,2:4,
      $ Is displacement sensitivity important AND does the edge gradient
      decline with displacement (y./n.)? $).

rule(kirsch:max,2:4,
      $ Is displacement sensitivity important AND does the edge gradient
      increase and then decrease (y./n.)? $).

rule(sobel:mag,2:4,
      $ Is displacement sensitivity not important AND relatively insensitive
      in small displacements but sensitive in large displacements (y./n.)? $).

rule(prewitt:mag,2:4, $ Is Signal - to - Noise ratio high (y./n.)? $).

rule($ Cannot give further more advisement! $).



/*                        CONTROL FUNCTIONS

   THIS SECTION DEFINES VARIOUS FUNCTIONS TO MANAGE THE BEHAIVOR OF
                                IMGEXP
*/
		

begin :- menu.


/*
   expert/0 introduces the abstract plan and interact with the user.
*/
expert :- abstract_plan, interact_with_user.

interact_with_user :- submenu(As,Sc), evaluate(As ,Sc).

/*
   evaluate/2 evaluates the outputs generated by the predicate
   submenu/2.
*/
evaluate(A,S) :-
    A == 0,
    S == 25,
    list_all,
    askif.

evaluate(A,S) :-
    A == 0,
    S == 31,
    show_steps_only.

evaluate(A,S) :-
    A == 0,
    S == 34,
    cls,
    advise.

evaluate(A,S) :-
    A == 0,
    S == 19,
    switch_main_menu.

evaluate(A,S) :-
    keyb(Asc,Sea),
    evaluate(Asc,Sea).


/*
  askif/0 is an auxiliary predicate to one of the 'evaluate/0'
  predicates. It is to ask the user what she wants to do at a end of a
  process.
*/
askif :-
    adjust,
    write('Return to previous menu ? (y./n.): '),
    read(y),
    switch_submenu,!.

askif :-
    adjust,
    write('Return to main menu ? (y./n.): '),
    switch_main_menu, !.

askif :- halt.


/*
  list_all/0 lists all tools that form a sound edge detection
  algorithm available in the knowledge base of IMGEXP.
*/
list_all :-
    set_cursor(6,7),
    cls,
    main_goal(OP,_Ys),
    main_decomp(OP,Ls),
    decompose(Ls),
    !.


/*
  decompose/1 is the triggering predicate of the decomposing process.
  Decomposing means making use of the Knowledge Representation (KR) to
  access each tool that is not further decomposable.
*/
decompose(Ls) :-
    non_decomposables(Ls,Ys),
    \+ bad_sequence(Ys),
    write_tool_comb(Ys),
    nl,
    fail.
decompose(_).


/*
   non_decomposable/2 is the integral part of decompose/1 predicate.
    Its purpose is to obtain only the operators ( or tools) whose
   'nondecomp/0' component in the KR is an empty list.
*/
non_decomposables([L|Ls],[Y|Ys]) :-
   tool(Op,L),
   Y = Op,
   non_decomposables(Ls,Ys).

non_decomposables([],[]).


/*
   write_tool_comb/1 is also an integral part of "decompose". It
   writes the possible sound tool combinations on the screen that are
   supposed to indicate a valid sequence of tools or operators.
*/
write_tool_comb([X|Xs]) :-
    write(X),
    tab(10),
    write_tool_comb(Xs).

write_tool_comb([]).


/*
  show_steps_only/0 leads the user through the steps which make up the
  edge detection algorithm while prompting the user to input her
  choices about specific tools without advising her.
*/
show_steps_only :-
    cls,
    content_a(X,Y,S),
    tmove(X,Y),
    write(S),
    content_aa(X1,Y1,S1),
    tmove(X1,Y1),
    write(S1),
    get_tool_choice(ChO),
    content_b(X2,Y2,S2),
    tmove(X2,Y2),
    write(S2),
    get_point_op(Chi),
    content_c(X3,Y3,S3),
    tmove(X3,Y3),
    write(S3),
    get_threshold(Ch2),
    users_selection(ChO ,Chi,Ch2) =.. F,
    control(F),
    get_request.


/*
   advise/0 leads the user through the steps which make up the
   edge detection algorithm while prompting the user to input her
   choices about specific tools without advising her.
*/
advise :-
    rule(T1:T2,X:Y,SO),
    tmove(X,Y),
    write(SO),
    answer,
    suggest(Tl,T2),
    get_tool_choice(TO),
    get_point_op(T3),
    get_threshold(T4),
    users_selection(TO,T3,T4) =.. FList,
    xcontrol(FList),
    get_resp.

advise :-
    adjust,
    rules(S),
    wa(36,9),
    write(S),
    adjust,
    get_resp.


/*
  answer/0 reads the input typed in by the user to the options displayed
   by IMGEXP.
*/

answer :-
    tget(X,Y),
    tmove(X,Y),
    read(y),
    !.

answer :-
    cls,
    fail.


/*
   suggest/2 puts forward a suggestion on how the user may select
   a specific operator combination regarding questions asked by IMGEXP.
*/
suggest(F,G) :-
    adjust,
    count(F - ZO),
    count(G - Zl),
    display(F,G,ZO,Zl).


/*
   display/4 displays suggestions made by 'suggest/0' to the user.
*/
display(F,G,N,N1) :-
    write('  In this case you should use the '),
    wa(N,112),
    write(F),
    %tab(1),
    write(' and the '),
    wa(N1,112),
    write(G),
    %tab(1),
    write(' operator.').


/*
    get_resp/0 prompts the user what to do next.
*/
get_resp :-
    adjust,
    write('Continue (y./n.): '),
    read(y),
    cls,
    advise.

get_resp :-
    switch_submenu.


/*  The following goals get the user inputs which is going to make up
    the edge detection algorithm.
*/
get_tool_choice(C) :-
    adjust,
    write(' Select tool: '),
    read(C).

get_point_op(C) :-
    adjust,
    write(' Select point operator: '),
    read(C).

get_threshold(C) :-
    adjust,
    write(' Select threshold value: '),
    read(C).

/*
    get_request/0 's functionalty is the same as 'get_resp/0'.
*/
get_request :-
    adjust,
    write(' Continue (y./n.): '),
    read(y),
    show_steps_only.

get_request :-
    switch_submenu.


/*
    control/1 is a component of show_steps_only/0 . It evaluates
    the user's input as insufficient/1 or error/1. IMGEXP uses
    error/1 when the operator sequence does not exist in the
    knowledge base and is not in advising mode.
*/
control(FI) :- error(FI),!.
control(FI) :- insufficient(FI),!.

error([users_selection,A,B,Thrs]) :-
    toolBox(Ts),
    member(A,Ts),
    member(B,Ts),
    content_d(X,Y,R),
    tmove(X,Y),
    write(R),
    write(' Operation Failed.').

error([users_selection,A,B,Thrs]) :-
    operatorBox(Ts),
    member(A,Ts),
    member(B,Ts),
    content_d(X,Y,R),
    tmove(X,Y),
    write(R),
    write(' Operation Failed.').


error([users_selection,A,B,Thrs]) :-
    operatorBox(Ts),
    \+ member(A,Ts),
    \+ member(B,Ts),
    content_d(X,Y,R),
    tmove(X,Y),
    write(R),
    write(' Operation Failed.').


/*
    The insufficient/1 predicate is triggered when the conditions inputted
    by the user are not accepted from the ES. This triggering process can
    be regarded as forward chaining, because the corresponding rules are
    fired away according to the data entered by the user.
*/
insufficient([users_selection,A,A,Thrs]) :-
    content_d(X,Y,R),
    tmove(X,Y),
    write(R),
    write(' Operation Failed.').

insufficient([users_selection,roberts,A,Thrs]) :-
    \+ A == rms,
    content_d(X,Y,R),
    tmove(X,Y),
    write(R),
    ((0 < Thrs, Thrs < 140, write(' Improvement required...')) |
    (Thrs < 0, Thrs > 255, write(' Operation Failed.'))        |
    (Thrs > 140, write(' Operation Succeeded.'))).

insufficient([users_selection,A,mag,Thrs]) :-
    (A == kirsch | A == three_level_template),
    content_d(X,Y,R),
    tmove(X,Y),
    write(R),
    ((0 < Thrs, Thrs < 100, write(' Improvement required...')) |
    (( Thrs < 0 | Thrs > 255), write(' Operation Failed.'))    |
    (Thrs >= 100, write(' Operation Succeeded.'))).

insufficient([users_selection,A,B,Thrs]) :-
    ( Thrs < 0 | Thrs > 255 ),
    content_d(X,Y,R),
    tmove(X,Y),
    write(R),
    write(' Operation Failed.').

insufficient([users_selection,A,B,Thrs]) :-
    (Thrs > 0 , Thrs =< 255),
    content_d(X,Y,R),
    tmove(X,Y),
    write(R),
    write(' Operation Succeeded.').

/*
    'xcontrol/0' inspects the entered input. By using 'explain_it/1' it
    directs the user to helpful actions in developing edge detection
    algorithms. 'look_for_error/1' looks for errors causing?
*/
xcontrol(FL) :- look_for_error(FL),!.
xcontrol(FL) :- explains(FL),!.

look_for_error([users_selection,A,B,Thrs]) :-
    toolBox(Ts),
    member(A,Ts),
    member(B,Ts),
    adjust,
    wa(24,240),
    write($Impossible to process...$),
    comment_text_g.

look_for_error([users_selection,A,B,Thrs]) :-
    operatorBox(Os),
    member(A,Os),
    member(B,Os),
    adjust,
    wa(24,240),
    write($Impossible to process...$),
    comment_text_h.

look_for_error([users_selection,A,B,Thrs]) :-
    toolBox(Ts),
    operatorBox(Os),
    \+ member(A,Ts),
    \+ member(B,Os),
    adjust,
    wa(24,240),
    write($Impossible to process...$),
    adjust,
    comment_text_m.

look_for_error([users_selection,_,B,Thrs]) :-
    operatorBox(Os),
    \+ member(B,Os),
    adjust,
    wa(24,240),
    write($Impossible to process...$),
    adjust,
    comment_text_j(B).

look_for_error([users_selection,A,_,Thrs]) :-
    toolBox(Ts),
    \+ member(A,Ts),
    adjust,
    wa(24,240),
    write($Impossible to process...$),
    adjust,
    comment_text_k(A).


/*
    The 'explain/1' predicate is triggered as much the same way as
    the 'insufficient/1' predicate. In addition to the same
    mechanism, by using 'explains/1' the IMGEXP can give advise to the
    user.
*/
explain([users_selection,A,A,Thrs]) :-
    adjust,
    wa(9,240),
    write($Warning!$),
    comment_text_i.

explain([users_selection,roberts,max,Thrs]) :-
    adjust,
    wa(9,240),
    write($Warning!$),
    comment_text_a.

explain([users_selection,A,mag,Thrs]) :-
    (A == kirsch | A == three_level_template),
    ((Thrs > 0, Thrs < 100,
       adjust,
       wa(9,240),
       write($Warning !$),
       comment_text_b) |
    (Thrs > 0, Thrs >= 100, Thrs < 255,
       adjust,
       comment,
       comment_text_c)).

explain([users_selection,roberts,mag,Thrs]) :-
    ((Thrs > 0, Thrs < 140,
       adjust,
       wa(9,240),
       write($Warning !$),
       comment_text_b ) |
    (Thrs > 0, Thrs >= 140, Thrs < 255,
       adjust,
       comment,
       comment_text_d)).

explain([users_selection,A,B,Thrs]) :-
    (Thrs < 0 | Thrs > 255),
       adjust,
       wa(9,240),
       write($Warning !$),
       adjust,
       comment_text_f.

explain([users_selection,A,B,Thrs]) :-
    Thrs > 0 , Thrs =< 255 ,
    adjust,
    wa(22,15),
    tab(1),
    write($ No Problems Occurred!$),
    comment_text_e.


/*
    The following predicates are called at miscellaneous parts in the
    program.
*/
switch_main_menu :- begin.

switch_submenu :-
    abstract_plan,
    submenu(G,H),
    evaluate(G,H).

/*
    'adjust/0' and 'adjust1/0' are used to adjust the coordinates at
    which the user enters his response.
*/
adjust :-
    tget(Q,P),
    inc(Q,Q1),
    P1 = 0,
    P2 is P1 + 3,
    tmove(Q1,P2).

adjust1 :-
    tget(Q,P),
    P1 = 0,
    P2 is P1 + 4,
    tmove(Q,P2).

member(X,[X|Xs]) :- !.
member(X,[Y|Ys]) :- member(X,Ys).



/*
             IMGEXP's TEXT SCREEN MANAGEMENT FUNCTIONS

*/


/*
    menu/0 prepares the main menu interface for the user.
*/
menu :-
    cls,
    set_cursor(5,3),
    
    heading(X,Y,M),
    print_on_screen(X,Y,M),
    
    altkey_a(A,S,T),
    print_altkey(A,S,T),

    item_1(X1,Y1,C,M1),
    print_on_screen(X1,Y1,C,M1),

    altkey_b(A1,S1,T1),
    print_altkey(A1,S1,T1),

    item_2(X2,Y2,Cl,M2),
    print_on_screen(X2,Y2,Cl,M2),

    keyb(Ascii,Scan),
    keyb_check_menu(Ascii,Scan),
    
    set_cursor(6,7), !.


/*
    submenu/2 is the menu from which the user can build up any edge
    detection algorithm.
*/

submenu(As,Sc) :-
    set_cursor(5,3),
    
    altkey_c(A,S,T),
    print_altkey(A,S,T),
    option_a(X,Y,Chr,StrO),
    sprint_on_screen(X,Y,Chr,StrO),
    
    altkey_d(A1,S1,T1),
    print_altkey(A1,S1,T1),
    option_b(X1,Y1,Chr1,Str1),
    sprint_on_screen(X1,Y1,Chr1,Str1),

    altkey_e(A2,S2,T2),
    print_altkey(A2,S2,T2),
    option_c(X2,Y2,Chr2,Str2),
    sprint_on_screen(X2,Y2,Chr2,Str2),

    altkey_f(A3,S3,T3),
    print_altkey(A3,S3,T3),
    option_d(X3,Y3,Chr3,Str3),
    sprint_on_screen(X3,Y3,Chr3,Str3),

    keyb(As,Sc), !.


/*
    print_altkey/3 prints the 'Alt - ?' options.
*/
print_altkey(H,J,K) :-
    tmove(H,J),
    wa(7,112),
    write(K).

/*
    keyb_check_menu/2 checks whether or not the appropriate key is pressed.
    To do this, is looks for the scan code of the pressed key.
*/
keyb_check_menu(A,S) :-
    A == 0,
    S == 18,
    expert.

keyb_check_menu(A,S) :-
    A == 0,
    S == 16,
    set_cursor(6,7),
    halt.

keyb_check_menu(A,S) :-
    keyb(As,Sc),
    keyb_check_menu(As,Sc).


/*
    abstract_plan/0 is the abstract plan for edge detection. It
    displays the plan on the screen.
*/
abstract_plan :-
    edge_heading(X,Y,StrO),
    print(X,Y,StrO),
    plan(X1,Y1),
    tmove(X1,Y1),
    draw_edge_plan, !.


/*
    print/3 is used for underlying the headings.
*/
print(Q,Q1,S) :-
    cls,
    tmove(Q,Q1),
    wa(32,1),
    write(S).


/*
    draw_edge_plan/0 and 'draw_the_plan/3 goals.
*/
draw_edge_plan :-
    edge_plan_list(Ps),
    tget(X,Y),
    draw_plan(X,Y,Ps).

draw_plan(X,Y,[T|Ts]) :-
    write(T),
    inc(X,X1),
    tmove(X1,Y),
    draw_plan(X1,Y,Ts).

draw_plan(_,_,[]).


/*
    print_on_screen/3 and sprint_on_screen/4 are involved in
    printing menu items on the screen.
*/
print_on_screen(X,Y,Ms) :-
    tmove(X,Y),
    wa(28,112),
    write(Ms).

print_on_screen(X,Y,CO,Ms) :-
    Y1 is Y - 1,
    tmove(X,Y1),
    wa(1,1),
    ( CO == 'E', write(CO),write(Ms))
	;
    ( CO == 'Q', write(CO), write(Ms)).

sprint_on_screen(X,Y,CO,Ms) :-
    K1 is Y - 1,
    tmove(X,K1),
    wa(1,1),
    (CO == 'P', write(CO), write(Ms))
	;
    (CO == 'S', write(CO), write(Ms))
	;
    (CO == 'G', write(CO), write(Ms))
	;
    (CO == 'Q', write(CO), write(Ms))
	;
    (CO == 'R', write(CO), write(Ms)).


/*
     THIS SECTION PROVIDES HEADINGS AND SUBHEADINGS OF THE USER
     INTERFACE
*/

heading(2, 26, $I M A G E   A N A L Y S I S $).

edge_heading(1, 24, $Abstract Plan For Edge Detection$).

item_1(8, 37,'E',$dge Detection$).
item_2(10, 37,'Q',$uit$).

altkey_a(8,26,  $Alt - E$).
altkey_b(10,26, $Alt - Q$).
altkey_c(13,15, $Alt - P$).
altkey_d(15,15, $Alt - S$).
altkey_e(17,15, $Alt - G$).
altkey_f(19,15, $Alt - R$).

option_a(13,27,'P', $ossible true combination of tools$).
option_b(15,27,'S', $tep by step implementation$).
option_c(17,27,'G', $ive advise while implementation$).
option_d(19,27,'R', $eturn to main menu$).

content_a(1, 4, $Spatial Operation -> Roberts - Sobel - Prewit $).
content_aa(2,4, $Spatial Operation - > Kirsch - 3 Level - Template $).
content_b(5,4,  $Point Operation - > rms - mag - max $).
content_c(8,4,  $Thresholding -> [ 0 - 255 ] $).
content_d(11,4, $Output -- > $).

comment :-
    wa(27,15),
    write($ Comment about your choice: $).

count(roberts - 7).
count(rms - 3).
count(kirsch - 6).
count(max - 3).
count(sobel - 5).
count(prewitt - 7).
count(mag - 3).
count(three_level_template - 20).

toolBox([roberts,sobel,prewitt,kirsch,three_level_template,
         compass_gradient]).

operatorBox([rms,mag,max]).

plan(4,10).

edge_plan_list([
                '                      Thresholding    ',
                '                                      ',
                'Edge Detection ------ Point Operation ',
                '                                      ',
                '                      Spatial Operation'
               ]).


/*
   IMGEXP uses these comments to guide the user to the correct
   direction.
*/

comment_text_a :-
    write($
          With this choice of algorithm, you have created many
          noisy induced false edges in the edge map.
          To get a better result, select the Sobel - Rms algorithm
          or the Prewitt - Mag algorithm.
          $).

comment_text_b :-
    write($
          You have created many noisy induced false edges in the
          output. To get rid of it, increase your threshold value.
          $).

comment_text_c :-
    write($
          If you had used a threshold value less than about 100, many
          noise induced false edges would have been created in the
          edge map.
          $).

comment_text_d :-
    write($
          If you had used a threshold value less than about 140, many
          noise induced false edges would have been created in the
          edge map.
	  $).

comment_text_e :-
    write($
          Operation succeeded because the neccessary conditions
          have been satisfied. But, when required, it is up to
          you to make more improvements on the outcome.
          $).

comment_text_f :- write($The threshold value is out of range.$).

comment_text_g :-
    write($
          You cannot use two tools consecutively. You have to use
          one tool and one operator.
	  $).

comment_text_h :-
    write($
          You cannot use two operators consecutively. You have to use
          one tool and one operator.
         $).

comment_text_i :-
    write($
          You cannot use two operators or two tools consecutively.
          You have to use first a tool and then a operator.
	 $).

comment_text_j(O) :-
    nl,
    tab(10),
    write('{'),
    write(O),
    write('}'),
    write($ operator does not exist in the Knowledge Base.$).

comment_text_k(T) :-
    nl,
    tab(10),
    write('{'),
    write(T),
    write('}'),
    write($ tool does not exist in the Knowledge Base.$).

comment_text_m :- 
    write($ Neither the tool nor the operator is present in the Knowledge Base.$)



/*                     End of IMGEXP Program                        */